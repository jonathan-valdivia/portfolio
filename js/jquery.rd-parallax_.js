// Generated by CoffeeScript 1.10.0

/**
 * @module       RD Parallax
 * @author       Evgeniy Gusarov
 * @see          https://ua.linkedin.com/pub/evgeniy-gusarov/8a/a40/54a
 * @version      3.2.1
 */

(function() {
  (function($, document, window) {

    /**
     * Initial flags
     * @public
     */
    var RDParallax, isIE, isMobile, isSafariIOS;
    isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    isSafariIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent) && !!navigator.userAgent.match(/Version\/[\d\.]+.*Safari/);
    isIE = navigator.appVersion.indexOf("MSIE") !== -1 || navigator.appVersion.indexOf('Trident/') > 0;

    /**
     * Creates a parallax.
     * @class RDParallax.
     * @public
     * @param {HTMLElement} element - The element to create the parallax for.
     * @param {Object} [options] - The options
     */
    RDParallax = (function() {

      /**
       * Default options for parallax.
       * @public
       */
      RDParallax.prototype.Defaults = {
        blur: true,
        direction: 'normal',
        speed: 1,
        offset: 0,
        screenAliases: {
          0: '',
          480: 'xs',
          768: 'sm',
          992: 'md',
          1200: 'lg',
          1920: 'xl',
          2560: 'xxl'
        }
      };

      function RDParallax(element, options) {
        this.options = $.extend(true, {}, this.Defaults, options);
        this.$element = $(element);
        this.$canvas = false;
        this.$win = $(window);
        this.$doc = $(document);
        this.$anchor = false;
        this.initialize();
      }


      /**
       * Initializes the Parallax.
       * @protected
       */

      RDParallax.prototype.initialize = function() {
        var ctx;
        ctx = this;
        ctx.$element.parents().each(function() {
          var el, hasMatrix, t, transforms;
          el = this;
          transforms = {
            'webkitTransform': '-webkit-transform',
            'OTransform': '-o-transform',
            'msTransform': '-ms-transform',
            'MozTransform': '-moz-transform',
            'transform': 'transform'
          };
          for (t in transforms) {
            if (transforms.hasOwnProperty(t)) {
              if (el.style[t] != null) {
                hasMatrix = window.getComputedStyle(el).getPropertyValue(transforms[t]);
              }
            }
          }
          if ((hasMatrix != null) && hasMatrix.length > 0 && hasMatrix !== "none") {
            ctx.$anchor = $(this);
            return false;
          }
        }).end().wrapInner($('<div/>', {
          "class": "rd-parallax-inner"
        })).find(".rd-parallax-layer[data-type]").each(function() {
          var layer, url;
          layer = $(this);
          switch (layer.attr("data-type").toLowerCase()) {
            case "media":
              if (url = this.getAttribute("data-url")) {
                layer.css({
                  "background-image": ctx.url(url)
                });
                if (this.getAttribute("data-blur") === "true" || ctx.options.blur) {
                  $('<img/>', {
                    src: url
                  }).load(function() {
                    layer.attr("data-media-width", this.width);
                    layer.attr("data-media-height", this.height);
                    if (!isMobile) {
                      ctx.$win.on("resize", $.proxy(ctx.blurMedia, layer[0], ctx));
                    }
                    return $.proxy(ctx.blurMedia, layer[0], ctx)();
                  });
                }
              }
              ctx.$element.on("resize", $.proxy(ctx.resizeMedia, this, ctx));
              ctx.$element.on("resize", $.proxy(ctx.moveLayer, this, ctx));
              if (!isMobile) {
                ctx.$win.on("resize", $.proxy(ctx.resizeMedia, this, ctx));
              } else {
                ctx.$win.on("orientationchange", $.proxy(ctx.resizeMedia, this, ctx));
              }
          }
          if (!isMobile) {
            ctx.$doc.on("scroll", $.proxy(ctx.moveLayer, this, ctx));
            ctx.$win.on("resize", $.proxy(ctx.moveLayer, this, ctx));
            if (this.getAttribute("data-fade") === "true") {
              ctx.$doc.on("scroll", $.proxy(ctx.fadeLayer, this, ctx));
              ctx.$win.on("resize", $.proxy(ctx.fadeLayer, this, ctx));
            }
          } else {
            ctx.$win.on("resize orientationchange", $.proxy(ctx.moveLayer, this, ctx));
          }
        });
        ctx.$canvas = ctx.$element.find(".rd-parallax-inner");
        if (ctx.$element.attr("data-fit-to-parent") === "true") {
          ctx.$win.on("resize", $.proxy(ctx.fitCanvas, ctx.$canvas, ctx));
        }
        if (!isMobile) {
          ctx.$win.on("resize", $.proxy(ctx.resizeWrap, ctx.$element[0], ctx));
          ctx.$win.on("resize", $.proxy(ctx.resizeCanvas, ctx.$canvas[0], ctx));
          ctx.$doc.on("scroll", $.proxy(ctx.moveCanvas, ctx.$canvas[0], ctx));
          ctx.$win.on("resize", $.proxy(ctx.moveCanvas, ctx.$canvas[0], ctx));
        }
        ctx.$win.trigger("resize");
        ctx.$win.trigger("orientationchange");
        ctx.$doc.trigger("scroll");
        ctx.$win.load(function() {
          ctx.$win.trigger("resize");
          ctx.$win.trigger("orientationchange");
          return ctx.$doc.trigger("scroll");
        });
      };


      /**
       * Moves Layer
       * @param {object} ctx
       * @protected
       */

      RDParallax.prototype.moveLayer = function(ctx) {
        var agent, ch, dh, dir, dy, h, offt, pos, sceneOn, scrt, v, wh;
        if ((sceneOn = ctx.getAttribute(ctx.$element[0], 'on')) != null) {
          if (sceneOn !== "true") {
            $(this).css({
              "-webkit-transform": "none",
              "transform": "none"
            });
            return;
          }
        }
        scrt = ctx.$win.scrollTop();
        offt = ctx.$element.offset().top;
        wh = ctx.$win.height();
        ch = ctx.$element.height();
        dh = ctx.$doc.height();
        h = this.offsetHeight;
        v = Math.max(parseFloat(v), 0);
        dir = ctx.getAttribute(this, 'direction') === "inverse" ? -1 : 1;
        v = dir * Math.min(parseFloat(ctx.getAttribute(this, 'speed')), 2.0);
        agent = this.getAttribute("data-agent");
        if ((agent = this.getAttribute("data-agent")) != null) {
          if ((agent = $(agent)).length) {
            dy = (offt + wh - (agent.offset().top + wh)) / (wh - ch);
          } else {
            dy = 0.5;
          }
        } else if (this.getAttribute("data-type") !== "media") {
          if (offt < wh || offt > dh - wh) {
            if (offt < wh) {
              dy = offt / (wh - ch);
            } else {
              dy = (offt + wh - dh) / (wh - ch);
            }
            if (!isFinite(dy)) {
              dy = 0;
            }
          } else {
            dy = 0.5;
          }
        } else {
          dy = 0.5;
        }
        if (!isMobile) {
          pos = -(offt - scrt) * v + (ch - h) / 2 + (wh - ch) * dy * v + parseInt(ctx.getAttribute(this, 'offset'));
          if ((scrt + wh >= offt && scrt <= offt + ch) || this.getAttribute("data-unbound") === "true") {
            return $(this).css(ctx.transform(pos, ctx));
          }
        } else {
          pos = (ch - h) / 2;
          return $(this).css(ctx.transform(pos, ctx));
        }
      };


      /**
       * Move Canvas
       * @param {object} ctx
       * @protected
       */

      RDParallax.prototype.moveCanvas = function(ctx, e) {
        var canvas, offt, pos, scrt;
        canvas = $(this);
        scrt = ctx.$win.scrollTop();
        offt = ctx.$element.offset().top;
        pos = (ctx.$anchor ? ctx.$element.position().top : offt - scrt);
        return canvas.css({
          "top": pos
        });
      };


      /**
       * Fade Layer
       * @param {object} ctx
       * @protected
       */

      RDParallax.prototype.fadeLayer = function(ctx, e) {
        var ch, coff, layer, loff, o, pos;
        layer = $(this);
        ch = ctx.$element.height();
        coff = ctx.$element.offset().top + ch / 2;
        loff = layer.offset().top + layer.height() / 2;
        pos = ch / 6.0;
        if (coff + pos > loff && coff - pos < loff) {
          return layer.css({
            "opacity": 1
          });
        } else {
          if (coff - pos < loff) {
            o = 1 + ((coff + pos - loff) / ch / 3.0 * 10);
          } else {
            o = 1 - ((coff - pos - loff) / ch / 3.0 * 10);
          }
          return layer.css({
            "opacity": o < 0 ? 0 : o > 1 ? 1 : o.toFixed(2)
          });
        }
      };


      /**
       * Blurs Layer
       * @param {object} ctx
       * @protected
       */

      RDParallax.prototype.blurMedia = function(ctx) {
        var blur, h, mh, mw, w;
        h = this.offsetHeight;
        w = this.offsetWidth;
        mh = parseFloat(this.getAttribute("data-media-height"));
        mw = parseFloat(this.getAttribute("data-media-width"));
        blur = Math.ceil(Math.max(h / mh, w / mw));
        return $(this).css(ctx.blur(blur));
      };


      /**
       * Resize Media Layer
       * @param {object} ctx
       * @protected
       */

      RDParallax.prototype.resizeMedia = function(ctx) {
        return this.style.height = ctx.px(ctx.getMediaHeight(ctx.$win.height(), ctx.$element.height(), ctx.getAttribute(this, 'speed'), ctx.getAttribute(this, 'direction') === "inverse" ? -1 : 1));
      };


      /**
       * Resize Main parallax wrap
       * @param {object} ctx
       * @protected
       */

      RDParallax.prototype.resizeWrap = function(ctx) {
        return this.style.height = ctx.px(ctx.$canvas.outerHeight());
      };


      /**
       * Resize Canvas
       * @param {object} ctx
       * @protected
       */

      RDParallax.prototype.resizeCanvas = function(ctx) {
        var $canvas;
        $canvas = $(this);
        return $canvas.css({
          "position": isIE && ctx.$anchor ? "relative" : "fixed",
          "left": (isIE ? "auto" : (ctx.$anchor ? ctx.$element.offset().left - ctx.$anchor.offset().left : ctx.$element.offset().left)),
          "width": ctx.$element.width()
        });
      };

      RDParallax.prototype.fitCanvas = function(ctx) {
        return setTimeout(function() {
          return ctx.$canvas.css({
            "height": ctx.$element.parent().parent().height()
          });
        });
      };


      /**
       * Calc media layer height.
       * @param {number} wh
       * @param {number} v
       * @returns {number} media layer height
       * @protected
       */

      RDParallax.prototype.getMediaHeight = function(wh, ch, v, dir) {
        var dh;
        v = Math.max(parseFloat(v), 0);
        v = Math.min(parseFloat(v), 2.0);
        dh = dir === -1 ? (ch + wh) * v : 0;
        return (ch + dh + (v <= 1 ? Math.abs(wh - ch) * v : wh * v)) + 56;
      };


      /**
       * Generates css background path.
       * @param {string} url
       * @returns {string} css url path
       * @protected
       */

      RDParallax.prototype.url = function(url) {
        return "url(" + url + ")";
      };


      /**
       * Converts Number to Pixels.
       * @param {number} num
       * @returns {string} pixels
       * @protected
       */

      RDParallax.prototype.px = function(num) {
        return num + "px";
      };


      /**
      * Creates transform property.
      * @param {number} pos
      * @param {object} ctx
      * @returns {object} CSS transform
      * @protected
       */

      RDParallax.prototype.transform = function(pos, ctx) {
        return {
          "-webkit-transform": "matrix3d(1,0,0.00,0,0.00,1,0.00,0,0,0,1,0,0," + pos + ",0,1)",
          "transform": "matrix3d(1,0,0.00,0,0.00,1,0.00,0,0,0,1,0,0," + pos + ",0,1)"
        };
      };


      /**
       * Creates blur property
       * @param {number} blur
       * @returns {object} CSS blur
       * @protected
       */

      RDParallax.prototype.blur = function(blur) {
        if (blur > 3) {
          return {
            '-webkit-filter': 'blur(' + blur + 'px)',
            'filter': 'blur(' + blur + 'px)'
          };
        } else {
          return {
            'filter': 'none',
            '-webkit-filter': 'none'
          };
        }
      };


      /**
      * Gets specific option of plugin
      * @protected
       */

      RDParallax.prototype.getAttribute = function(element, key) {
        var alias, aliases, attr, i, j, ref;
        if (this.options.screenAliases != null) {
          aliases = Object.keys(this.options.screenAliases).reverse();
          for (i = j = 0, ref = aliases.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
            alias = this.options.screenAliases[aliases[i]] !== '' ? "-" + this.options.screenAliases[aliases[i]] : this.options.screenAliases[aliases[i]];
            attr = element.getAttribute("data" + alias + "-" + key);
            if (aliases[i] <= this.$win.width() && (attr != null)) {
              break;
            }
          }
        }
        if (attr != null) {
          return attr;
        } else {
          return this.options[key];
        }
      };

      return RDParallax;

    })();

    /**
     * The jQuery Plugin for the RD Parallax
     * @public
     */
    $.fn.extend({
      RDParallax: function(options) {
        return this.each(function() {
          var $this;
          $this = $(this);
          if (!$this.data('RDParallax')) {
            return $this.data('RDParallax', new RDParallax(this, options));
          }
        });
      }
    });
    return window.RDParallax = RDParallax;
  })(window.jQuery, document, window);


  /**
   * The Plugin AMD export
   * @public
   */

  if (typeof module !== "undefined" && module !== null) {
    module.exports = window.RDParallax;
  } else if (typeof define === 'function' && define.amd) {
    define(["jquery"], function() {
      'use strict';
      return window.RDParallax;
    });
  }

}).call(this);
